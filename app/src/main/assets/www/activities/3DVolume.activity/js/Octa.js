function createOctahedron(e,t,n,o,l,r,a,c,i,E,s,w,u,N,f,h,p,d,T){let y,R=null==t?s.showNumbers:t,m=null==n?s.toggleTransparent:n,C=null!=e?e:s.presentColor,H=null!=E?E:s.textColor;if(R){let e=new THREE.Vector2(4,5),t=512,n=new THREE.OctahedronGeometry(1.6),o=document.createElement("canvas");o.width=t*e.x,o.height=t*e.y;let l=o.getContext("2d");l.fillStyle=C,l.fillRect(0,0,o.width,o.height);let r=[],a=[[.067,.25],[.933,.25],[.5,1]].map((e=>new THREE.Vector2(...e)));for(let n=0;n<9;n++){let c=n%e.x,i=Math.floor(n/e.x);r.push((a[0].x+c)/e.x,(a[0].y+i)/e.y,(a[1].x+c)/e.x,(a[1].y+i)/e.y,(a[2].x+c)/e.x,(a[2].y+i)/e.y),l.textAlign="center",l.textBaseline="middle",l.font="bold 200px Arial",l.fillStyle=H,l.fillText(n+1+"",(c+.5)*t,o.height-(i+.5)*t)}n.setAttribute("uv",new THREE.Float32BufferAttribute(r,2));let c=new THREE.CanvasTexture(o);c.colorSpace=THREE.SRGBColorSpace;let i=new THREE.MeshPhongMaterial({map:c});y=new THREE.Mesh(n,i)}else if(m){const t=new THREE.OctahedronGeometry(1.6),n=new THREE.WireframeGeometry(t),o=new THREE.LineBasicMaterial({color:null!=e?e:s.presentColor,depthTest:!0,opacity:1,transparent:!1});y=new THREE.LineSegments(n,o)}else{const t=new THREE.OctahedronGeometry(1.6),n=new THREE.MeshPhongMaterial({color:null!=e?e:s.presentColor,wireframe:!1});y=new THREE.Mesh(t,n)}y.castShadow=!0,y.userData=T,N.add(y);const x=[new CANNON.Vec3(1.6,0,0),new CANNON.Vec3(-1.6,0,0),new CANNON.Vec3(0,1.6,0),new CANNON.Vec3(0,-1.6,0),new CANNON.Vec3(0,0,1.6),new CANNON.Vec3(0,0,-1.6)],V=new CANNON.ConvexPolyhedron({vertices:x,faces:[[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]]});let g=null==o?xCoordinate:o,v=null==l?zCoordinate:l,M=null==c?10:1;const O=new CANNON.Body({mass:2,shape:V,position:new CANNON.Vec3(g,M,v),material:new CANNON.Material,restitution:.3});u.addBody(O),null!=o&&O.sleep();const A=new CANNON.ContactMaterial(f,O.material,{friction:s.friction});u.addContactMaterial(A);let S=null==h?.9*Math.random()+.1:h,b=null==p?.9*Math.random()+.1:p,B=null==d?.9*Math.random()+.1:d;O.angularVelocity.set(S,b,B),O.angularDamping=.1,O.applyImpulse(s.offset,s.rollingForce),y.position.copy(O.position),y.quaternion.copy(O.quaternion),null!=i&&null!=i&&(y.quaternion.copy(i),O.quaternion.copy(i)),w.push([y,O,"octa",R,m,C,H,S,b,B,A])}function getOctaScore(e,t,n){const o=[{vector:new THREE.Vector3(1,0,0),face:4},{vector:new THREE.Vector3(-1,0,0),face:6},{vector:new THREE.Vector3(0,1,0),face:5},{vector:new THREE.Vector3(0,-1,0),face:3},{vector:new THREE.Vector3(1,1,1).normalize(),face:1},{vector:new THREE.Vector3(-1,1,1).normalize(),face:8},{vector:new THREE.Vector3(1,-1,1).normalize(),face:2},{vector:new THREE.Vector3(-1,-1,1).normalize(),face:7}];let l,r=1e6;for(let e=0;e<o.length;e++){let n=o[e];n.vector.applyEuler(t.rotation),r>Math.abs(1-n.vector.y)&&(r=Math.abs(1-n.vector.y),l=e)}return n||(e.lastRoll+=o[l].face+" + ",e.presentScore+=o[l].face),o[l].face}