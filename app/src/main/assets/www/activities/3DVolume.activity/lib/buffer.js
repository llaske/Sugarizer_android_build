!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).BufferGeometryUtils={},e.THREE)}(this,(function(e,t){"use strict";function mergeBufferAttributes(e){let t,r,o,n=0;for(let i=0;i<e.length;++i){const s=e[i];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=s.array.constructor),t!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=s.itemSize),r!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=s.normalized),o!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;n+=s.array.length}const i=new t(n);let s=0;for(let t=0;t<e.length;++t)i.set(e[t].array,s),s+=e[t].array.length;return new THREE.BufferAttribute(i,r,o)}e.computeMorphedAttributes=function computeMorphedAttributes(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const t=new THREE.Vector3,r=new THREE.Vector3,o=new THREE.Vector3,n=new THREE.Vector3,i=new THREE.Vector3,s=new THREE.Vector3,u=new THREE.Vector3,a=new THREE.Vector3,l=new THREE.Vector3;function _calculateMorphedAttributeData(e,f,c,m,g,d,h,b,p){t.fromBufferAttribute(c,d),r.fromBufferAttribute(c,h),o.fromBufferAttribute(c,b);const E=e.morphTargetInfluences;if(f.morphTargets&&m&&E){u.set(0,0,0),a.set(0,0,0),l.set(0,0,0);for(let e=0,f=m.length;e<f;e++){const f=E[e],c=m[e];0!==f&&(n.fromBufferAttribute(c,d),i.fromBufferAttribute(c,h),s.fromBufferAttribute(c,b),g?(u.addScaledVector(n,f),a.addScaledVector(i,f),l.addScaledVector(s,f)):(u.addScaledVector(n.sub(t),f),a.addScaledVector(i.sub(r),f),l.addScaledVector(s.sub(o),f)))}t.add(u),r.add(a),o.add(l)}e.isSkinnedMesh&&(e.boneTransform(d,t),e.boneTransform(h,r),e.boneTransform(b,o)),p[3*d+0]=t.x,p[3*d+1]=t.y,p[3*d+2]=t.z,p[3*h+0]=r.x,p[3*h+1]=r.y,p[3*h+2]=r.z,p[3*b+0]=o.x,p[3*b+1]=o.y,p[3*b+2]=o.z}const f=e.geometry,c=e.material;let m,g,d;const h=f.index,b=f.attributes.position,p=f.morphAttributes.position,E=f.morphTargetsRelative,A=f.attributes.normal,y=f.morphAttributes.position,T=f.groups,B=f.drawRange;let w,R,H,G,x,M,U,D;const S=new Float32Array(b.count*b.itemSize),v=new Float32Array(A.count*A.itemSize);if(null!==h)if(Array.isArray(c))for(w=0,H=T.length;w<H;w++)for(x=T[w],M=c[x.materialIndex],U=Math.max(x.start,B.start),D=Math.min(x.start+x.count,B.start+B.count),R=U,G=D;R<G;R+=3)m=h.getX(R),g=h.getX(R+1),d=h.getX(R+2),_calculateMorphedAttributeData(e,M,b,p,E,m,g,d,S),_calculateMorphedAttributeData(e,M,A,y,E,m,g,d,v);else for(U=Math.max(0,B.start),D=Math.min(h.count,B.start+B.count),w=U,H=D;w<H;w+=3)m=h.getX(w),g=h.getX(w+1),d=h.getX(w+2),_calculateMorphedAttributeData(e,c,b,p,E,m,g,d,S),_calculateMorphedAttributeData(e,c,A,y,E,m,g,d,v);else if(Array.isArray(c))for(w=0,H=T.length;w<H;w++)for(x=T[w],M=c[x.materialIndex],U=Math.max(x.start,B.start),D=Math.min(x.start+x.count,B.start+B.count),R=U,G=D;R<G;R+=3)m=R,g=R+1,d=R+2,_calculateMorphedAttributeData(e,M,b,p,E,m,g,d,S),_calculateMorphedAttributeData(e,M,A,y,E,m,g,d,v);else for(U=Math.max(0,B.start),D=Math.min(b.count,B.start+B.count),w=U,H=D;w<H;w+=3)m=w,g=w+1,d=w+2,_calculateMorphedAttributeData(e,c,b,p,E,m,g,d,S),_calculateMorphedAttributeData(e,c,A,y,E,m,g,d,v);return{positionAttribute:b,normalAttribute:A,morphedPositionAttribute:new THREE.Float32BufferAttribute(S,3),morphedNormalAttribute:new THREE.Float32BufferAttribute(v,3)}},e.computeTangents=function computeTangents(e){e.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.")},e.estimateBytesUsed=function estimateBytesUsed(e){let t=0;for(const r in e.attributes){const o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t},e.interleaveAttributes=function interleaveAttributes(e){let t,r=0,o=0;for(let n=0,i=e.length;n<i;++n){const i=e[n];if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=i.array.length,o+=i.itemSize}const n=new THREE.InterleavedBuffer(new t(r),o);let i=0;const s=[],u=["getX","getY","getZ","getW"],a=["setX","setY","setZ","setW"];for(let t=0,r=e.length;t<r;t++){const r=e[t],o=r.itemSize,l=r.count,f=new THREE.InterleavedBufferAttribute(n,o,i,r.normalized);s.push(f),i+=o;for(let e=0;e<l;e++)for(let t=0;t<o;t++)f[a[t]](e,r[u[t]](e))}return s},e.mergeBufferAttributes=mergeBufferAttributes,e.mergeBufferGeometries=function mergeBufferGeometries(e,t=!1){const r=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),i={},s={},u=e[0].morphTargetsRelative,a=new THREE.BufferGeometry;let l=0;for(let f=0;f<e.length;++f){const c=e[f];let m=0;if(r!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in c.attributes){if(!o.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===i[e]&&(i[e]=[]),i[e].push(c.attributes[e]),m++}if(m!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". Make sure all geometries have the same number of attributes."),null;if(u!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in c.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[e]&&(s[e]=[]),s[e].push(c.morphAttributes[e])}if(a.userData.mergedUserData=a.userData.mergedUserData||[],a.userData.mergedUserData.push(c.userData),t){let e;if(r)e=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". The geometry must have either an index or a position attribute"),null;e=c.attributes.position.count}a.addGroup(l,e,f),l+=e}}if(r){let t=0;const r=[];for(let o=0;o<e.length;++o){const n=e[o].index;for(let e=0;e<n.count;++e)r.push(n.getX(e)+t);t+=e[o].attributes.position.count}a.setIndex(r)}for(const e in i){const t=mergeBufferAttributes(i[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;a.setAttribute(e,t)}for(const e in s){const t=s[e][0].length;if(0===t)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let o=0;o<s[e].length;++o)t.push(s[e][o][r]);const o=mergeBufferAttributes(t);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;a.morphAttributes[e].push(o)}}return a},e.mergeVertices=function mergeVertices(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},o=e.getIndex(),n=e.getAttribute("position"),i=o?o.count:n.count;let s=0;const u=Object.keys(e.attributes),a={},l={},f=[],c=["getX","getY","getZ","getW"];for(let t=0,r=u.length;t<r;t++){const r=u[t];a[r]=[];const o=e.morphAttributes[r];o&&(l[r]=new Array(o.length).fill().map((()=>[])))}const m=Math.log10(1/t),g=Math.pow(10,m);for(let t=0;t<i;t++){const n=o?o.getX(t):t;let i="";for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.getAttribute(r),s=o.itemSize;for(let e=0;e<s;e++)i+=~~(o[c[e]](n)*g)+","}if(i in r)f.push(r[i]);else{for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.getAttribute(r),i=e.morphAttributes[r],s=o.itemSize,f=a[r],m=l[r];for(let e=0;e<s;e++){const t=c[e];if(f.push(o[t](n)),i)for(let e=0,r=i.length;e<r;e++)m[e].push(i[e][t](n))}}r[i]=s,f.push(s),s++}}const d=e.clone();for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.getAttribute(r),n=new o.array.constructor(a[r]),i=new THREE.BufferAttribute(n,o.itemSize,o.normalized);if(d.setAttribute(r,i),r in l)for(let t=0;t<l[r].length;t++){const o=e.morphAttributes[r][t],n=new o.array.constructor(l[r][t]),i=new THREE.BufferAttribute(n,o.itemSize,o.normalized);d.morphAttributes[r][t]=i}}return d.setIndex(f),d},e.toTrianglesDrawMode=function toTrianglesDrawMode(e,t){if(t===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===THREE.TriangleFanDrawMode||t===THREE.TriangleStripDrawMode){let r=e.getIndex();if(null===r){const t=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<o.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}const o=r.count-2,n=[];if(t===THREE.TriangleFanDrawMode)for(let e=1;e<=o;e++)n.push(r.getX(0)),n.push(r.getX(e)),n.push(r.getX(e+1));else for(let e=0;e<o;e++)e%2==0?(n.push(r.getX(e)),n.push(r.getX(e+1)),n.push(r.getX(e+2))):(n.push(r.getX(e+2)),n.push(r.getX(e+1)),n.push(r.getX(e)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(n),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}}));