!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("cannon"),require("three")):"function"==typeof define&&define.amd?define(["cannon","three"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).CannonDebugger=t(e.CANNON,e.THREE)}(this,(function(e,t){"use strict";return function CannonDebugger(e,t,n){let{color:o=65280,scale:s=1,onInit:r,onUpdate:a}=void 0===n?{}:n;const c=[],i=new THREE.MeshBasicMaterial({color:null!=o?o:65280,wireframe:!0}),u=new CANNON.Vec3,p=new CANNON.Vec3,E=new CANNON.Vec3,l=new CANNON.Quaternion,h=new THREE.SphereGeometry(1),f=new THREE.BoxGeometry(1,1,1),y=new THREE.PlaneGeometry(10,10,10,10);function createMesh(t){let n=new THREE.Mesh;const{SPHERE:o,BOX:s,PLANE:r,CYLINDER:a,CONVEXPOLYHEDRON:c,TRIMESH:l,HEIGHTFIELD:N}=CANNON.Shape.types;switch(t.type){case o:n=new THREE.Mesh(h,i);break;case s:n=new THREE.Mesh(f,i);break;case r:n=new THREE.Mesh(y,i);break;case a:{const e=new THREE.CylinderGeometry(t.radiusTop,t.radiusBottom,t.height,t.numSegments);n=new THREE.Mesh(e,i),t.geometryId=e.id;break}case c:{const e=function createConvexPolyhedronGeometry(e){const t=new THREE.BufferGeometry,n=[];for(let t=0;t<e.vertices.length;t++){const o=e.vertices[t];n.push(o.x,o.y,o.z)}t.setAttribute("position",new THREE.Float32BufferAttribute(n,3));const o=[];for(let t=0;t<e.faces.length;t++){const n=e.faces[t],s=n[0];for(let e=1;e<n.length-1;e++){const t=n[e],r=n[e+1];o.push(s,t,r)}}return t.setIndex(o),t.computeBoundingSphere(),t.computeVertexNormals(),t}(t);n=new THREE.Mesh(e,i),t.geometryId=e.id;break}case l:{const e=function createTrimeshGeometry(e){const t=new THREE.BufferGeometry,n=[],o=u,s=p,r=E;for(let t=0;t<e.indices.length/3;t++)e.getTriangleVertices(t,o,s,r),n.push(o.x,o.y,o.z),n.push(s.x,s.y,s.z),n.push(r.x,r.y,r.z);return t.setAttribute("position",new THREE.Float32BufferAttribute(n,3)),t.computeBoundingSphere(),t.computeVertexNormals(),t}(t);n=new THREE.Mesh(e,i),t.geometryId=e.id;break}case N:{const e=function createHeightfieldGeometry(e){const t=new THREE.BufferGeometry,n=e.elementSize||1,o=e.data.flatMap(((e,t)=>e.flatMap(((e,o)=>[t*n,o*n,e])))),s=[];for(let t=0;t<e.data.length-1;t++)for(let n=0;n<e.data[t].length-1;n++){const o=e.data[t].length,r=t*o+n;s.push(r+1,r+o,r+o+1),s.push(r+o,r+1,r)}return t.setIndex(s),t.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),t.computeBoundingSphere(),t.computeVertexNormals(),t}(t);n=new THREE.Mesh(e,i),t.geometryId=e.id;break}}return e.add(n),n}function updateMesh(t,n){let o=c[t],r=!1;return function typeMatch(e,t){if(!e)return!1;const{geometry:n}=e;return n instanceof THREE.SphereGeometry&&t.type===CANNON.Shape.types.SPHERE||n instanceof THREE.BoxGeometry&&t.type===CANNON.Shape.types.BOX||n instanceof THREE.PlaneGeometry&&t.type===CANNON.Shape.types.PLANE||n.id===t.geometryId&&t.type===CANNON.Shape.types.CYLINDER||n.id===t.geometryId&&t.type===CANNON.Shape.types.CONVEXPOLYHEDRON||n.id===t.geometryId&&t.type===CANNON.Shape.types.TRIMESH||n.id===t.geometryId&&t.type===CANNON.Shape.types.HEIGHTFIELD}(o,n)||(o&&e.remove(o),c[t]=o=createMesh(n),r=!0),function scaleMesh(e,t){const{SPHERE:n,BOX:o,PLANE:r,CYLINDER:a,CONVEXPOLYHEDRON:c,TRIMESH:i,HEIGHTFIELD:u}=CANNON.Shape.types;switch(t.type){case n:{const{radius:n}=t;e.scale.set(n*s,n*s,n*s);break}case o:e.scale.copy(t.halfExtents),e.scale.multiplyScalar(2*s);break;case r:break;case a:case c:e.scale.set(1*s,1*s,1*s);break;case i:e.scale.copy(t.scale).multiplyScalar(s);break;case u:e.scale.set(1*s,1*s,1*s)}}(o,n),r}return y.translate(0,0,1e-4),{update:function update(){const n=c,o=u,s=l;let i=0;for(const e of t.bodies)for(let t=0;t!==e.shapes.length;t++){const c=e.shapes[t],u=updateMesh(i,c),p=n[i];p&&(e.quaternion.vmult(e.shapeOffsets[t],o),e.position.vadd(o,o),e.quaternion.mult(e.shapeOrientations[t],s),p.position.copy(o),p.quaternion.copy(s),u&&r instanceof Function&&r(e,p,c),!u&&a instanceof Function&&a(e,p,c)),i++}for(let t=i;t<n.length;t++){const o=n[t];o&&e.remove(o)}n.length=i}}}}));